import { readFileSync } from 'fs';

interface CommentarySchema {
  title: string;
  proposal_id: string;
  canister_id?: string;
  commit_summaries?: Array<{
    commit_hash: string;
    summary: string;
  }>;
  file_summaries?: Array<{
    file_path: string;
    summary: string;
  }>;
  overall_summary: string;
  why_now?: string;
  sources: Array<{
    type: string;
    url?: string;
    description: string;
  }>;
  confidence_notes?: string;
  analysis_incomplete: boolean;
  incomplete_reason?: string;
}

interface ClaudeMessage {
  type: string;
  role?: string;
  content?: string | Array<{ type: string; text?: string }>;
}

function extractJsonFromText(text: string): CommentarySchema | null {
  // Try to find JSON object in the text
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      return JSON.parse(jsonMatch[0]);
    } catch {
      return null;
    }
  }
  return null;
}

function findCommentaryInOutput(outputPath: string): CommentarySchema | null {
  const raw = readFileSync(outputPath, 'utf-8');
  const data = JSON.parse(raw);

  // The output is an array of messages - find the last assistant message with JSON
  const messages = Array.isArray(data) ? data : [data];

  // Search backwards for the final JSON output
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];

    if (msg.type === 'assistant' || msg.role === 'assistant') {
      // Handle both string content and array content
      let text = '';
      if (typeof msg.content === 'string') {
        text = msg.content;
      } else if (Array.isArray(msg.content)) {
        text = msg.content
          .filter((c: any) => c.type === 'text')
          .map((c: any) => c.text || '')
          .join('\n');
      }

      const commentary = extractJsonFromText(text);
      if (commentary && commentary.title && commentary.overall_summary) {
        return commentary;
      }
    }
  }

  return null;
}

function formatSourceLink(source: { type: string; url?: string; description: string }): string {
  const typeEmoji: Record<string, string> = {
    proposal_body: 'ðŸ“œ',
    git_diff: 'ðŸ”€',
    github_pr: 'ðŸ”—',
    forum_post: 'ðŸ’¬',
    documentation: 'ðŸ“š',
    other: 'ðŸ“Ž',
  };

  const emoji = typeEmoji[source.type] || 'ðŸ“Ž';

  if (source.url) {
    return `- ${emoji} [${source.description}](${source.url})`;
  }
  return `- ${emoji} ${source.description}`;
}

function formatCommentaryAsMarkdown(commentary: CommentarySchema): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${commentary.title}`);
  lines.push('');

  // Metadata
  lines.push(`**Proposal ID:** ${commentary.proposal_id}`);
  if (commentary.canister_id) {
    lines.push(`**Canister:** \`${commentary.canister_id}\``);
  }
  lines.push('');

  // Warning if incomplete
  if (commentary.analysis_incomplete) {
    lines.push('> âš ï¸ **Analysis Incomplete**');
    if (commentary.incomplete_reason) {
      lines.push(`> ${commentary.incomplete_reason}`);
    }
    lines.push('');
  }

  // Overall Summary
  lines.push('## Summary');
  lines.push('');
  lines.push(commentary.overall_summary);
  lines.push('');

  // Why Now
  if (commentary.why_now) {
    lines.push('## Why Now');
    lines.push('');
    lines.push(commentary.why_now);
    lines.push('');
  }

  // Commit Summaries
  if (commentary.commit_summaries && commentary.commit_summaries.length > 0) {
    lines.push('## Commits');
    lines.push('');
    for (const commit of commentary.commit_summaries) {
      lines.push(`### \`${commit.commit_hash.substring(0, 8)}\``);
      lines.push('');
      lines.push(commit.summary);
      lines.push('');
    }
  }

  // File Summaries
  if (commentary.file_summaries && commentary.file_summaries.length > 0) {
    lines.push('## File Changes');
    lines.push('');
    for (const file of commentary.file_summaries) {
      lines.push(`### \`${file.file_path}\``);
      lines.push('');
      lines.push(file.summary);
      lines.push('');
    }
  }

  // Sources
  if (commentary.sources && commentary.sources.length > 0) {
    lines.push('## Sources');
    lines.push('');
    for (const source of commentary.sources) {
      lines.push(formatSourceLink(source));
    }
    lines.push('');
  }

  // Confidence Notes
  if (commentary.confidence_notes) {
    lines.push('## Notes');
    lines.push('');
    lines.push(`> ${commentary.confidence_notes}`);
    lines.push('');
  }

  lines.push('---');
  lines.push('*Generated by Claude Code*');

  return lines.join('\n');
}

async function main() {
  const outputPath = process.argv[2] || '/home/runner/work/_temp/claude-execution-output.json';

  try {
    const commentary = findCommentaryInOutput(outputPath);

    if (!commentary) {
      console.error('Could not find valid commentary JSON in Claude output');
      console.log('## Commentary Generation Failed');
      console.log('');
      console.log('Could not extract structured commentary from Claude output.');
      process.exit(1);
    }

    const markdown = formatCommentaryAsMarkdown(commentary);
    console.log(markdown);

  } catch (err) {
    console.error('Error formatting commentary:', err);
    process.exit(1);
  }
}

main();
